
## 1. 交易被用户使用eth_sendRawTransaction接口发送给执行层客户端，交易会如何被保存？
在Web3.0的以太坊生态中，当用户通过`eth_sendRawTransaction`接口发送一笔签名交易后，交易会经历以下流程被保存和执行：

---

### 1.1 **交易提交到执行层客户端**
   - 用户构造交易并签名，生成**RLP编码的原始交易数据**（RawTransaction）。
   - 通过JSON-RPC调用`eth_sendRawTransaction`将交易发送到连接的执行层客户端（如Geth、Nethermind等）。

---

### 1.2 **交易验证与临时存储（交易池）**
   - **验证阶段**：
     - 客户端验证交易签名、Nonce、Gas等基本合法性。
     - 检查账户余额是否足够支付Gas费用。
     - 拒绝无效交易（返回错误）。
   - **存入交易池（Mempool）**：
     - 有效交易被存入节点的本地**交易池**，这是一个临时存储区。
     - 交易池按Gas Price和Nonce排序，优先处理高Gas交易。

---

### 1.3 **广播到P2P网络**
   - 执行层客户端通过**Devp2p协议**将交易广播给其他节点。
   - 其他节点重复验证流程，并加入各自的交易池，形成去中心化传播。

---

### 1.4 **打包到区块**
   - **验证者/矿工**从交易池选择交易，按优先级打包到新区块。
     - 在PoW中，矿工打包；在PoS（如以太坊2.0）中，验证者负责。
   - 交易被包含在区块的**交易列表**中，成为区块链的一部分。

---

### 1.5 **区块确认与最终存储**
   - 区块通过共识机制（如PoS的LMD-GHOST）被确认。
   - 执行层客户端将区块数据写入本地区块链数据库（如LevelDB/RocksDB），交易被永久保存。
   - 交易状态（成功/失败）由EVM执行结果决定，并更新世界状态。

---

### 关键存储位置
1. **交易池（内存）**：临时存储未确认交易，重启后消失。
2. **区块链数据库（磁盘）**：交易最终以区块形式持久化存储。
3. **状态树（Merkle Patricia Trie）**：交易导致的状态变更存储在状态树中。

---

### 补充说明
- **去中心化**：交易需要被多数节点验证和存储，确保一致性。
- **交易生命周期**：若交易长时间未打包，可能因Gas过低被丢弃。
- **客户端差异**：不同客户端（Geth vs. Erigon）的存储优化方式可能不同（如Erigon的归档模式）。

通过这一流程，交易从用户提交到最终上链，实现了去中心化、不可篡改的存储。


2. 交易被保存后，如何被选中？

3. 一个交易消耗的gas如何计算？是什么时候从sender账户扣除？

4. 创建合约交易和普通交易处理方式的区别？

5. 创建合约有什么限制？

6. 交易是怎么被广播给其他执行层客户端的？

7. PoW(Proof of Work)与PoS(Proof of Stake)?

8. PoW时期，矿工如何赚取收益？收益什么时候被添加到账户？

9. PoW时期，如何产生一个新块？并把区块广播出去？

10. 合并到PoS后，新区块如何同步？